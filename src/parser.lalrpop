use std::iter::FromIterator;

use lexer;
use ast;

grammar;

pub Program: ast::Program = {
    <lines:Line*> => ast::Program {
        statements: Vec::from_iter(lines.into_iter().flatten())
    },
};

Line: ast::Suite = {
    Statement,
    CompoundStatement,
    "\n" => vec![],
};

Statement: ast::Suite = {
    AssignStatement,
    ExpressionStatement,
    PassStatement,
};

CompoundStatement: ast::Suite = {
    IfStatement,
};

AssignStatement: ast::Suite = {
    <ident: Identifier> "=" <expr: Expression> => vec![
        ast::Statement::Assign { ident: ident, expr: expr, },
    ],
};

ExpressionStatement: ast::Suite = {
    <expr: Expression> => vec![
        ast::Statement::Expression { expr: expr, },
    ],
};

PassStatement: ast::Suite = {
    "pass" => vec![ast::Statement::Pass],
};

IfStatement: ast::Suite = {
    "if" <expr: Expression> ":" "\n" "indent" <stmt: Statement> "\n" "unindent" => vec![
        ast::Statement::IfStatement {
            expr: expr,
            stmt: stmt,
        },
    ],
};

Operator: ast::Operator = {
    "=" => ast::Operator::Equals,
    "+" => ast::Operator::Plus,
    "-" => ast::Operator::Minus,
    "*" => ast::Operator::Multiply,
    "/" => ast::Operator::Divide,
};

Expression: ast::Expression = {
    ConditionalExpression,
};

ConditionalExpression: ast::Expression = {
    OrTest,
};

OrTest: ast::Expression = {
    AndTest,
    <left: OrTest> "or" <right: AndTest> =>
        ast::Expression::BinaryOperation {
            left: Box::new(left),
            op: ast::Operator::LogicalOr,
            right: Box::new(right)
        },
};

AndTest: ast::Expression = {
    NotTest,
    <left: AndTest> "and" <right: NotTest> =>
        ast::Expression::BinaryOperation {
            left: Box::new(left),
            op: ast::Operator::LogicalAnd,
            right: Box::new(right)
        },
};

NotTest: ast::Expression = {
    Comparison,
    "not" <expr: NotTest> =>
        ast::Expression::UnaryOperation {
            op: ast::Operator::LogicalNot,
            expr: Box::new(expr),
        },
};

Comparison: ast::Expression = {
    OrExpr,
};

OrExpr: ast::Expression = {
    XorExpr,
};

XorExpr: ast::Expression = {
    AndExpr,
};

AndExpr: ast::Expression = {
    ShiftExpr,
};

ShiftExpr: ast::Expression = {
    ArithmeticExpr,
};

ArithmeticOperator: ast::Operator = {
    "+" => ast::Operator::Plus,
    "-" => ast::Operator::Minus,
};

ArithmeticExpr: ast::Expression = {
    MultExpr,
    <left: ArithmeticExpr> <op: ArithmeticOperator> <right: MultExpr> =>
        ast::Expression::BinaryOperation {
            left: Box::new(left),
            op: op,
            right: Box::new(right),
        },
};

MultOperator: ast::Operator = {
    "*" => ast::Operator::Multiply,
    "/" => ast::Operator::Divide,
};

MultExpr: ast::Expression = {
    UnaryExpr,
    <left: MultExpr> <op: MultOperator> <right: UnaryExpr> =>
        ast::Expression::BinaryOperation {
            left: Box::new(left),
            op: op,
            right: Box::new(right),
        },
};

UnaryExpr: ast::Expression = {
    PowerExpr,
};

PowerExpr: ast::Expression = {
    Primary,
};

Primary: ast::Expression = {
    Atom,
};

Atom: ast::Expression = {
    <ident: Identifier> => ast::Expression::Identifier { name: ident },
    <literal: Literal> => ast::Expression::Literal { value: literal },
    Enclosure,
};

Identifier: ast::Identifier = {
    <ident: "identifier"> => ast::Identifier::Name { name: ident },
};

Literal: ast::Literal = {
    <i: "integer"> => ast::Literal::Integer { value: i },
};

Enclosure: ast::Expression = {
    "(" <expr: Expression> ")" =>
        ast::Expression::ParenExpression { expr: Box::new(expr) },
};

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        "indent" => lexer::Tok::Indent,
        "unindent" => lexer::Tok::Unindent,
        "identifier" => lexer::Tok::Identifier { name: <String> },
        "pass" => lexer::Tok::Pass,
        "if" => lexer::Tok::If,
        "or" => lexer::Tok::LogicalOr,
        "and" => lexer::Tok::LogicalAnd,
        "not" => lexer::Tok::LogicalNot,
        "=" => lexer::Tok::Equals,
        "+" => lexer::Tok::Plus,
        "-" => lexer::Tok::Minus,
        "*" => lexer::Tok::Multiply,
        "/" => lexer::Tok::Divide,
        "integer" => lexer::Tok::Integer { value: <u32> },
        "(" => lexer::Tok::LPar,
        ")" => lexer::Tok::RPar,
        ":" => lexer::Tok::Colon,
        "\n" => lexer::Tok::Newline,
    }
}

// vim: ft=rust
